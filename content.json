{"meta":{"title":"梦的天空之城","subtitle":null,"description":"走自己的路，我无所谓","author":"xinsane","url":"https://hexo.xinsane.com"},"pages":[{"title":"标签","date":"2018-04-05T14:04:02.000Z","updated":"2019-01-08T04:35:20.742Z","comments":false,"path":"tags/index.html","permalink":"https://hexo.xinsane.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-04-05T13:58:56.000Z","updated":"2019-01-08T04:35:08.662Z","comments":false,"path":"categories/index.html","permalink":"https://hexo.xinsane.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"编译linux-4.19内核并添加自定义文件系统","slug":"编译linux-4.19内核并添加自定义文件系统","date":"2018-12-23T10:31:35.000Z","updated":"2018-12-29T04:03:44.592Z","comments":true,"path":"2018/12/23/编译linux-4.19内核并添加自定义文件系统/","link":"","permalink":"https://hexo.xinsane.com/2018/12/23/编译linux-4.19内核并添加自定义文件系统/","excerpt":"","text":"实验目的 设计一个类似 ext2 的自定义文件系统 myext2 添加自定义文件系统到 linux 内核中 测试自定义文件系统 实验过程本次实验使用 linux-4.19 内核版本，基于ext2文件系统，除了文件系统的magic number不同之外基本没有修改，只是为了了解和测试基本操作。 准备编译环境1sudo apt install git fakeroot build-essential ncurses-dev xz-utils libssl-dev bc flex libelf-dev bison 下载源码可以从 Github 上下载源码，这里我选取了当前的最新稳定版 v4.19 作为测试版本。下载后解压到工作目录，源码就准备完毕了。 注：由于该项目的commit特别多，不建议以git clone的方式获取代码，因为这会花费相当多的时间。 修改代码添加文件系统fs/myext2目录的修改以ext2文件系统为蓝本，修改成自定义的myext2文件系统，基本修改如下所示：123456789101112# 复制ext2文件系统到myext2作为自定义文件系统的蓝本cp -r fs/ext2 fs/myext2cd fs/myext2# 替换文件名（大小写都需要替换）rename \"s/ext2/myext2/\" *rename \"s/EXT2/MYEXT2/\" *# 替换文件内容（大小写都需要替换）sed -i \"s/ext2/myext2/g\" `grep ext2 -rl ./`sed -i \"s/EXT2/MYEXT2/g\" `grep EXT2 -rl ./` 需要特别注意，现在的myext2文件系统中是没有定义myext2_set_bit_atomic和myext2_clear_bit_atomic这两个函数的，参照ext4的做法，简单的定义一个预编译宏即可。123// file: fs/myext2/myext2.hline 20: #define myext2_set_bit_atomic ext2_set_bit_atomicline 21: #define myext2_clear_bit_atomic ext2_clear_bit_atomic fs目录的修改除了对myext2目录文件的修改，还需要对fs/Kconfig和fs/Makefile作相应的修改，修改的基本原则是，只要出现了ext2的配置，就复制一份到myext2的配置（大写的EXT2也是如此）。123456789101112131415161718192021222324# 可以像这样查找需要处理的内容，也可以直接打开文件查找，需要修改的内容并不多cat fs/Kconfig | grep -ni ext2cat fs/Makefile | grep -ni ext2# 修改后的内容部分如下所示# Kconfig# 引入子目录下的Kconfigsource \"fs/ext2/Kconfig\"source \"fs/myext2/Kconfig\"config FS_MBCACHE# Meta block cache for Extended Attributes (ext2/ext3/ext4)# 这一段代码用于指定下一步配置中FS_MBCACHE的默认值 tristate default y if EXT2_FS=y &amp;&amp; EXT2_FS_XATTR default y if MYEXT2_FS=y &amp;&amp; MYEXT2_FS_XATTR default y if EXT4_FS=y default m if EXT2_FS_XATTR || EXT4_FS default m if MYEXT2_FS_XATTR || EXT4_FS# Makefile# 编译子目录obj-$(CONFIG_EXT2_FS) += ext2/obj-$(CONFIG_MYEXT2_FS) += myext2/ include目录的修改添加myext2_fs.h包含头文件：1234# 添加myext2文件系统的基础支持，添加后需要像之前一样替换掉所有大小写的ext2cp include/linux/ext2_fs.h include/linux/myext2_fs.hsed -i \"s/ext2/myext2/g\" include/linux/myext2_fs.hsed -i \"s/EXT2/MYEXT2/g\" include/linux/myext2_fs.h 修改自定义文件系统的magic number：123// file: include/uapi/linux/magic.hline 22: #define EXT2_SUPER_MAGIC 0xEF53line 23: #define MYEXT2_SUPER_MAGIC 0x6666 基本配置与编译安装在这一步中，需要配置编译好的内核需要打包哪些内容和模块，在menuconfig中，带*号的表示打包到二进制内核文件中，带M标识的表示以模块的形式加载。 在Kconfig文件中指定了一些默认值，即使全新配置也不需要从零开始。但是从当前系统拷贝一份配置再进行修改比全新配置更适合本机系统，相对全新配置不容易出错一点。在配置时应特别注意文件系统子配置项中是否配置了新增文件系统的模块。 123456789101112131415161718192021# 拷贝当前系统内核配置到工作目录，也可以不执行这一步而进行配置cp /boot/config-$(uname -r) .config# 图形化配置make menuconfig# 编译内核和各模块make# 安装模块（默认安装位置为/lib/modules）make modules_install# 安装内核并更新grub（默认安装位置为/boot）make install# 重启系统sudo reboot# 查看内核是否更新成功uname -r # 查看内核版本号uname -a # 查看内核完整版本信息 在make menuconfig完成之后，编译时出现了如下错误：1No rule to make target &apos;debian/certs/benh@debian.org.cert.pem&apos;, needed by &apos;certs/x509_certificate_list&apos;. 这里投机取巧直接注释掉CONFIG_SYSTEM_TRUSTED_KEYS就可以成功编译了。12// file: .configline 8205: # CONFIG_SYSTEM_TRUSTED_KEYS=&quot;&quot; 设计格式化工具内核安装成功后，并不能直接使用mkfs -t myext2 /dev/{target}，因为编译的内核中并不包含格式化工具mkfs.myext21mkfs: failed to execute mkfs.myext2: No such file or directory 其实，myext2文件系统与ext2在物理布局上除了magic number完全一致，所以替代方案就是使用mkfs.ext2代替然后修改magic number。修改magic number可以直接使用hexedit搜索53EF（0xEF53的存储方式是低字节在前）修改成6666。为了方便修改，写了一段简单的C语言程序：123456789101112131415161718192021222324252627282930#include &lt;stdio.h&gt;int main(int argc, char *argv[])&#123; if(argc &lt; 2) &#123; printf(\"usage: %s %s\\n\", argv[0], \"filename\"); return 1; &#125; FILE* file = fopen(argv[1], \"r+b\"); if (file == NULL) &#123; printf(\"can not to open file: %s\\n\", argv[1]); return 1; &#125; fseek(file, 0x438, SEEK_SET); unsigned short magic = 0; fread(&amp;magic, 2, 1, file); if (0xef53 == magic) &#123; fseek(file, 0x438, SEEK_SET); magic = 0x6666; fwrite(&amp;magic, 2, 1, file); printf(\"magic number changed 0x%x =&gt; 0x%x\\n\", 0xef53, magic); &#125; else printf(\"magic number = 0x%x.\\nnot a ext2 format. magic number not changed.\\n\", magic); fclose(file); return 0;&#125; 测试自定义文件系统12345dd if=/dev/zero of=./vfs bs=1M count=1mkfs.ext2 ./vfs./chmn ./vfs# 输出magic number changed 0xef53 =&gt; 0x6666 分别建立两个目录，同时挂载刚创建的虚拟文件系统，可以正常的读写文件，且对任意挂载目录进行修改都会反映到其他挂载目录，部分操作和输出如下所示：1234567891011121314root@kali:~/workspace# mkdir vfs_mountroot@kali:~/workspace# mkdir vfs_mount_cloneroot@kali:~/workspace# mount -t myext2 ./vfs ./vfs_mount -o looproot@kali:~/workspace# mount -t myext2 ./vfs ./vfs_mount_clone -o looproot@kali:~/workspace# ls vfs_mountlost+foundroot@kali:~/workspace# mkdir vfs_mount/testroot@kali:~/workspace# echo 123 &gt; vfs_mount_clone/test.txtroot@kali:~/workspace# ls vfs_mountlost+found test test.txtroot@kali:~/workspace# cat vfs_mount/test.txt123root@kali:~/workspace# ls vfs_mount_clonelost+found test test.txt","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hexo.xinsane.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://hexo.xinsane.com/tags/Linux/"}]},{"title":"Apache如何rewrite到子目录","slug":"Apache如何rewrite到子目录","date":"2018-09-13T08:25:39.000Z","updated":"2018-09-13T08:39:15.583Z","comments":true,"path":"2018/09/13/Apache如何rewrite到子目录/","link":"","permalink":"https://hexo.xinsane.com/2018/09/13/Apache如何rewrite到子目录/","excerpt":"","text":"今天遇到一个非常紧急的问题，看起来也很常见，就是网站的一个子模块不是直接提供服务的，而是在public子目录下提供网页，然而不能把public带进URL里面，就是说我的URL应该是这样的/submodule/index.html，文件地址应该是这样的submodule/public/index.html。 然而网站结构前期已经定好，不能直接把public子目录配置为网站的根目录（这个模块本身就在网站根目录的子目录下面），所以需要在这个模块的目录下配置重写规则rewrite到public子目录。于是乎，我想当然的配置了如下.htaccess： 123456&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteRule ^(.*)$ public/$1&lt;/IfModule&gt; 然而Apache却报了500错误，查日志，Rewrite次数过多。什么意思呢？就是在第一次进入子模块目录时，加上了一个public之后，会从头再来一次，再一次进入这个目录，继续重写，无限循环，就爆炸了。怎么办？实测在Rule后面加L标记是无效的。 Google搜索：Apache如何rewrite到子目录，无果。我就纳闷了，这个需求应该很常见吧，怎么就搜不到呢？再搜英文，依然无果。难道是我的打开方式不对？ 折腾了很久，最后终于发现一个神器（所谓神奇就是不知道为什么就可以了）： 1234567&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks -Multiviews RewriteEngine On RewriteRule ^public(.*)$ - [L] RewriteRule ^(.*)$ public/$1&lt;/IfModule&gt; 两条Rule依次执行，当发现当前URL已经有了public，直接中断查询，于是就不会溢出了（中间的-意思是只匹配不替换），大概可能是这样？最后我试了一下，子目录再子目录也是可以的，只要再复制一份.htaccess到子目录就行了。","categories":[{"name":"Apache","slug":"Apache","permalink":"https://hexo.xinsane.com/categories/Apache/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"https://hexo.xinsane.com/tags/Apache/"}]},{"title":"Ubuntu16.04交叉编译OpenWrt版本scutclient","slug":"Ubuntu16-04交叉编译OpenWrt版本scutclient","date":"2018-06-30T18:25:50.000Z","updated":"2018-06-30T18:33:09.004Z","comments":true,"path":"2018/07/01/Ubuntu16-04交叉编译OpenWrt版本scutclient/","link":"","permalink":"https://hexo.xinsane.com/2018/07/01/Ubuntu16-04交叉编译OpenWrt版本scutclient/","excerpt":"","text":"按照官方文档的说法一步步来，需要openwrt sdk和scutclient的Makefile文件即可。在编译的过程主要遇到以下两个问题： 1. awk123456……awk: include/scan.awk: line 21: function asort never definedawk: include/scan.awk: line 21: function asort never definedawk: include/scan.awk: line 21: function asort never definedawk: include/scan.awk: line 21: function asort never defined…… 这是因为没有安装gawk1sudo apt install gawk 2. ccache123……configure: error: C compiler cannot create executables…… 这是因为没有安装ccache1sudo apt install ccache","categories":[],"tags":[]},{"title":"RecyclerView探幽 - Adapter、ViewHolder、ItemList","slug":"RecyclerView探幽 - Adapter、ViewHolder、ItemList","date":"2018-05-12T07:21:22.000Z","updated":"2018-06-30T18:34:59.637Z","comments":true,"path":"2018/05/12/RecyclerView探幽 - Adapter、ViewHolder、ItemList/","link":"","permalink":"https://hexo.xinsane.com/2018/05/12/RecyclerView探幽 - Adapter、ViewHolder、ItemList/","excerpt":"","text":"Adapter中的onCreateViewHolder和onBindViewHolder在实现Adapter的时候，至少需要重写三个方法：getItemCount、onCreateViewHolder和onBindViewHolder，getItemCount一般是返回数据表的长度，比较简单，但是onCreateViewHolder和onBindViewHolder中遇到的坑比较多。 ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)这个方法中会构造两个东西，一个叫View，很熟悉，另一个叫ViewHolder，虽然不那么熟悉，但是顾名思义ViewHolder就是用来装View的容器。可以把View中的一些控件提取出来放到ViewHolder中存起来，避免每次都findViewById，也可以把一些与View相关的临时变量放在里面，最重要的一点就是ViewHolder与View永久绑定，所以把View对象的引用存在ViewHolder中可以随时从ViewHolder中获取对应的View来操作视图。Javadoc是这样写的：12345678910111213141516171819Called when RecyclerView needs a new ViewHolder of the given type to representan item.当RecyclerView需要一个对应类型的新的ViewHolder时会调用这个方法。This new ViewHolder should be constructed with a new View that can represent theitems of the given type. You can either create a new View manually or inflate itfrom an XML layout file.你应当用一个对应类型的view来初始化一个ViewHolder，你可以自己构建这个view，也可以通过XML布局文件中构建。The new ViewHolder will be used to display items of the adapter usingonBindViewHolder(ViewHolder, int, List). Since it will be re-used to displaydifferent items in the data set, it is a good idea to cache references to subviews of the View to avoid unnecessary View.findViewById(int) calls.这个新的ViewHolder将会在onBindViewHolder中绑定数据并显示在屏幕上。因为它会在更换数据的时候重复利用，所以在ViewHolder中保存子视图的引用来减少findViewById的调用是个不错的做法。 这里有个坑，这里创建的ViewHolder和与之对应的View永久绑定，但是它们跟数据只是临时绑定！什么意思呢，绝对不可以把数据放在ViewHolder里面，因为ViewHolder和Data的关系会变。举个例子，ViewHolder相当于抽屉，在抽屉里放东西（Data），一个抽屉里面的东西可以是你有的任何一件，东西的数量可以远大于抽屉数量，因为多的可以不放在抽屉里，但是ViewHolder的数量就那么多，它不会随着东西的增多而变多。 void onBindViewHolder(ViewHolder holder, int position)这个方法在数据与View-ViewHolder绑定的时候被调用的，看Javadoc：123456789101112131415161718192021Called by RecyclerView to display the data at the specified position. This method shouldupdate the contents of the ViewHolder.itemView to reflect the item at the given position.RecyclerView在特定位置显示数据的时候会调用这个方法，这个方法应当根据对应位置的数据来更新ViewHolder中对应的View视图。Note that unlike ListView, RecyclerView will not call this method again if the position of the item changes in the data set unless the item itself is invalidated or the newposition cannot be determined. For this reason, you should only use the position parameterwhile acquiring the related data item inside this method and should not keep a copy of it.If you need the position of an item later on (e.g. in a click listener), useViewHolder.getAdapterPosition() which will have the updated adapter position.注意它将不同于ListView，在完成绑定之后，当对应位置的数据被修改之后，这个方法不会被重新调用，除非item本身已经失效或者新的位置无法确定。（在数据改变时，开发者应当主动地调用notify*系列方法通知刷新视图，之后RecyclerView会重新调用这个方法重新绑定视图）。因为这个原因，你应该用position参数从DataList中获取数据而不能把数据存在ViewHolder里面。如果在之后需要获取position，可以用ViewHolder.getAdapterPosition()来实时获取当时绑定的数据position。Override onBindViewHolder(ViewHolder, int, List) instead if Adapter can handle efficientpartial bind. 多种Item类型的应用待更新…","categories":[],"tags":[]},{"title":"树莓派的那些事","slug":"树莓派的那些事","date":"2018-04-25T09:28:37.000Z","updated":"2018-04-25T17:05:45.018Z","comments":true,"path":"2018/04/25/树莓派的那些事/","link":"","permalink":"https://hexo.xinsane.com/2018/04/25/树莓派的那些事/","excerpt":"","text":"引言树莓派入手很久了，一直搁置在那也没怎么用，最近突发奇想就拿来重新刷了系统，遇到了很多问题，故简单地记录一下。 安装系统本次选择了官方系统的Lite版，基于Debian，我使用的版本是2018年4月18日更新的，其他版本其实应该都大同小异，但据了解Lite版和Desktop版差别挺大的。还是给个传送门吧。刷入系统我选择的是官方推荐的ETCher，界面十分简约，功能也十分简约，就是专门用来干这个的，当然其他的刷入工具也是可以的。 开启ssh其实这个系统默认就是有安装好ssh，只是默认没有开启而已。启动ssh1sudo /etc/init.d/ssh start 或者配置开机自启后再启动12sudo systemctl enable sshsudo systemctl start ssh 然后就可以用电脑通过ssh访问了顺便记录一下，官方系统默认帐号是pi，默认密码是raspberryssh连接之前记得查看一下树莓派的ip地址1ifconfig 我用路由器给我的树莓派绑定了固定ip地址，或者可以在树莓派里配置静态ip，具体方法不再赘述。 禁止密码登陆ssh首先修改默认用户密码，以免被别人趁虚而入。1passwd 然后建立.ssh目录上传公钥1234cd ~mkdir .sshcd .sshnano authorized_keys 然后粘贴公钥，Ctrl+O 保存，Ctrl+X 退出nano（使用其他编辑器比如vi也可以，我习惯用nano，后面的编辑都会用这个编辑器），然后退出shell尝试使用密钥登陆，如果能登陆成功，就可以禁止密码登陆了1sudo nano /etc/ssh/sshd_config 找到PasswordAuthentication这一项1#PasswordAuthentication yes 取消注释并改成no1PasswordAuthentication no 然后保存退出，重启ssh服务1sudo systemctl restart ssh 然后退出shell，再登陆时就只能用密钥登陆了 换源 or 代理？树莓派的官方源在境外，国内访问会比较慢，网上的说法比较倾向于换源，这也确实是一个很不错的方法。但是在实际的使用中，一定要确认使用的源是否正确。我开始换了阿里的源，速度确实非常快，但是很多包安装不了，大部分报情况下显示，可能请求了一个不稳定版的软件并且缺少一些依赖，这种情况下无法自动安装依赖（正常情况下安装一个软件缺少依赖时会自动安装），网上可以通过列出所有的依赖然后依次安装的方法解决这个问题，但是我发现只要换回了官方源就不会有这个问题。同时国内的源跟官方源不匹配也是一个问题，有时候国内会更新的慢很多，所以在换源的时候一定要小心了。最后我还是决定使用代理的方式来解决速度慢的问题（理论上使用代理网络请求，请求同样是要出境，但经过实际测试使用代理就是会比正常访问快很多，我也没有具体研究原因）。 使用 shadowsocks-libev + privoxy 实现自由命令行代理安装 shadowsocks-libev1sudo apt install shadowsocks-libev 配置文件在 /etc/shadowsocks-libev/config.json，填写好服务器的配置 配置登陆时自动启动在 /etc/rc.local 后面 exit 0 前面添加一行：（会把日志文件输出到pi用户的用户根目录的ss.log）1su pi -c &quot;nohup ss-local &gt; /home/pi/ss.log 2&gt;&amp;1 &amp;&quot; 安装 privoxy现在虽然shadowsocks已经能够自动启动了，但是ss-local使用的是socks5代理，http协议是不能用它来代理的，所以需要一个名为privoxy的软件：1sudo apt install privoxy 配置 privoxy 全局代理1sudo nano /etc/privoxy/whitelist.action 写入以下内容：12345678910111213&#123;&#123;alias&#125;&#125;# 代理(socks5)socks5 = +forward-override&#123;forward-socks5 127.0.0.1:1080 .&#125;# 直连direct = +forward-override&#123;forward .&#125;# 所有网站走代理&#123;socks5&#125;/# 以下网站走直连&#123;direct&#125;.ip.cn.chinaz.com 其中端口号要与ss-local一致，这里我使用了1080端口然后把 actionsfile whitelist.action 添加到 /etc/privoxy/config 的末尾就完成了配置最后重启privoxy并设置开机自启，看一下是否启动成功：123sudo systemctl enable privoxysudo systemctl start privoxysudo systemctl status privoxy 目前，只要配置了 http_proxy 和 https_proxy 环境变量就能使用代理了，但是一旦配置了这个环境变量，所有的请求都会代理，如果希望选择性的代理，可以使用 gfwlist 实现 pac 模式，关于这点，我并没有过多的了解。 编写 proxy 脚本实现自由代理所谓自由代理就是希望代理的时候通过在命令前加上 proxy 关键字进行代理访问，不需要代理的请求不加这个关键字就行了，无需其他配置。建议把脚本放在 /usr/local/bin/proxy1sudo nano /usr/local/bin/proxy 写入以下内容：12#!/bin/bashhttp_proxy=http://127.0.0.1:8118 https_proxy=http://127.0.0.1:8118 $* 其中端口号要与 privoxy 的配置一致，默认是8118然后赋予可执行权限：1sudo chmod +x /usr/local/bin/proxy 至此，所有配置完成，重启后，需要代理的命令使用proxy前缀，比如：1sudo proxy apt install git 修改默认交换文件的大小1sudo nano /etc/dphys-swapfile 修改其中的1CONF_SWAPSIZE=100 为1CONF_SWAPSIZE=2048 就有2G的虚拟内存，应该够用了，最后执行：12sudo dphys-swapfile setupsudo dphys-swapfile swapon 重新加载一下配置文件，然后就可以用 free 命令查看到 2G 虚拟内存了 让 shell 界面有颜色pi用户的shell界面默认是有颜色的，但是root用户默认没有，只要把pi用户的.bashrc文件中对应的部分复制到root用户的.bashrc中就可以达到目的1234567891011121314151617181920212223242526272829303132333435363738case &quot;$TERM&quot; in xterm-color|*-256color) color_prompt=yes;;esacforce_color_prompt=yesif [ -n &quot;$force_color_prompt&quot; ]; then if [ -x /usr/bin/tput ] &amp;&amp; tput setaf 1 &gt;&amp;/dev/null; then color_prompt=yes else color_prompt= fifiif [ &quot;$color_prompt&quot; = yes ]; then PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\\[\\033[01;32m\\]\\u@\\h\\[\\033[00m\\]:\\[\\033[01;34m\\]\\w \\$\\[\\033[00m\\] &apos;else PS1=&apos;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h:\\w\\$ &apos;fiunset color_prompt force_color_promptcase &quot;$TERM&quot; inxterm*|rxvt*) PS1=&quot;\\[\\e]0;$&#123;debian_chroot:+($debian_chroot)&#125;\\u@\\h: \\w\\a\\]$PS1&quot; ;;*) ;;esacif [ -x /usr/bin/dircolors ]; then test -r ~/.dircolors &amp;&amp; eval &quot;$(dircolors -b ~/.dircolors)&quot; || eval &quot;$(dircolors -b)&quot; alias ls=&apos;ls --color=auto&apos; alias grep=&apos;grep --color=auto&apos; alias fgrep=&apos;fgrep --color=auto&apos; alias egrep=&apos;egrep --color=auto&apos;fialias ll=&apos;ls -al&apos; 最后一句 alias 是把 ll 变成 ls -al 的别名，方便查看文件 安装 apache2 + php7 + mysql + phpmyadmin123sudo apt install apache2sudo apt install mysql-server mysql-clientsudo apt install php php-mysql mysql创建最高权限用户1GRANT ALL PRIVILEGES ON *.* TO admin@localhost IDENTIFIED BY &apos;password&apos; WITH GRANT OPTION; 安装phpmyadmin以phpMyAdmin-4.8.0.1为例（我修改了apache2的默认配置，网站根目录在 /var/www）123456789sudo mkdir /opt/phpmyadmincd /opt/phpmyadminsudo curl -O https://files.phpmyadmin.net/phpMyAdmin/4.8.0.1/phpMyAdmin-4.8.0.1-all-languages.zipsudo unzip phpMyAdmin-4.8.0.1-all-languages.zipsudo ln -s /opt/phpmyadmin/phpMyAdmin-4.8.0.1-all-languages /var/www/phpmyadminsudo cp /var/www/phpmyadmin/config.sample.inc.php /var/www/phpmyadmin/config.inc.phpsudo mkdir /var/www/phpmyadmin/tmpsudo chown www-data -R /var/www/phpmyadmin/tmpsudo chgrp www-data -R /var/www/phpmyadmin/tmp 安装tomcat创建tomcat用户和组12sudo groupadd tomcatsudo useradd -s /bin/false -g tomcat -d /opt/tomcat tomcat 以9.0.7版本为例下载源码并配置12345678910sudo mkdir /opt/tomcatcd /opt/tomcatsudo curl -O http://mirrors.shu.edu.cn/apache/tomcat/tomcat-9/v9.0.7/bin/apache-tomcat-9.0.7.zipsudo unzip apache-tomcat-9.0.7.zipsudo mv -R apache-tomcat-9.0.7 9.0.7sudo ln -s /opt/tomcat/9.0.7 /opt/tomcat/latest# 修改权限sudo chown tomcat -R 9.0.7sudo chgrp tomcat -R 9.0.7sudo chmod 744 -R /opt/tomcat/latest/bin/*.sh 配置开机启动1sudo update-java-alternatives -l 记下jdk路径（RASPBIAN系统+openjdk的sdk位置默认是 /usr/lib/jvm/java-1.8.0-openjdk-armhf）1sudo nano /etc/systemd/system/tomcat.service 写入以下内容12345678910111213141516171819[Unit]Description=Apache Tomcat Web Application ContainerAfter=network.target[Service]Type=forkingEnvironment=JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-armhf/jreEnvironment=CATALINA_PID=/opt/tomcat/latest/temp/tomcat.pidEnvironment=CATALINA_HOME=/opt/tomcat/latestEnvironment=CATALINA_BASE=/opt/tomcat/latestEnvironment=&apos;CATALINA_OPTS=-Xms512M -Xmx1024M -server -XX:+UseParallelGC&apos;Environment=&apos;JAVA_OPTS=-Djava.awt.headless=true -Djava.security.egd=file:/dev/./urandom&apos;ExecStart=/opt/tomcat/latest/bin/startup.shExecStop=/opt/tomcat/latest/bin/shutdown.shUser=tomcatGroup=tomcat[Install]WantedBy=multi-user.target 注意替换jdk位置，以及其后的jre不能遗漏，内存配置按需修改重新加载systemctl、配置开机启动、启动tomcat以及查看是否成功启动：1234sudo systemctl daemon-reloadsudo systemctl enable tomcatsudo systemctl start tomcatsudo systemctl status tomcat 配置tomcat web管理接口修改：1sudo nano /opt/tomcat/latest/conf/tomcat-users.xml 在tomcat-users中添加一行1&lt;user username=&quot;tomcat&quot; password=&quot;password&quot; roles=&quot;manager-gui,admin-gui&quot;/&gt; 修改META-INF权限配置，需要修改以下两个文件，允许局域网访问12sudo nano /opt/tomcat/latest/webapps/manager/META-INF/context.xmlsudo nano /opt/tomcat/latest/webapps/host-manager/META-INF/context.xml 两个文件中12345&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\\.lang\\.(?:Boolean|Integer|Long|Number|String)|org\\.apache\\.catalina\\.filters\\.CsrfPreventionFilter\\$LruCache(?:\\$1)?|java\\.util\\.(?:Linked)?HashMap&quot;/&gt;&lt;/Context&gt; 都需要把1allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; 修改为1allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|192\\.168\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; 即允许来自192.168.开头的IP的访问，这样就可以通过局域网管理web应用了最终文件长这个样子：12345&lt;Context antiResourceLocking=&quot;false&quot; privileged=&quot;true&quot; &gt; &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot; allow=&quot;127\\.\\d+\\.\\d+\\.\\d+|192\\.168\\.\\d+\\.\\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt; &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\\.lang\\.(?:Boolean|Integer|Long|Number|String)|org\\.apache\\.catalina\\.filters\\.CsrfPreventionFilter\\$LruCache(?:\\$1)?|java\\.util\\.(?:Linked)?HashMap&quot;/&gt;&lt;/Context&gt;","categories":[{"name":"树莓派","slug":"树莓派","permalink":"https://hexo.xinsane.com/categories/树莓派/"}],"tags":[{"name":"树莓派","slug":"树莓派","permalink":"https://hexo.xinsane.com/tags/树莓派/"},{"name":"Debian","slug":"Debian","permalink":"https://hexo.xinsane.com/tags/Debian/"}]},{"title":"SpringMVC学习心得","slug":"SpringMVC学习心得","date":"2018-04-21T07:36:31.000Z","updated":"2018-04-21T09:19:53.138Z","comments":true,"path":"2018/04/21/SpringMVC学习心得/","link":"","permalink":"https://hexo.xinsane.com/2018/04/21/SpringMVC学习心得/","excerpt":"","text":"引言在这里记录一下在初学SpringMVC中遇到的一些问题或编码习惯。强调一下，这主要是一些个人习惯，不是教程，更不适合初学者看。现在的新开始的网站基本都会前后分离，Web后台的开发重心基本都转向了API开发，所以我就在这方面死磕了2333 Controller类注解API控制器类的注解12345@Controller@RequestMapping(value = \"/api/main/sub\", produces = &#123; \"application/json;charset=UTF-8\" &#125;, method = RequestMethod.POST)@ResponseBody @Controller用来说明这是一个控制器，需要在SpringMVC的配置文件中指定自动扫描指定base-package之后，该包及下面的所有子孙包都会被自动扫描1&lt;context:component-scan base-package=\"com.xinsane.controller\"/&gt; @RequestMapping.value指定该控制器的基本路径，我一般习惯以api开头，这样完整路径为：/api/{模块}/{控制器}/{方法}，没错，我可能ThinkPHP学傻了，但是不得不承认，这种设计方式在很多时候还是很不错的 @RequestMapping.produces这个属性是用来指定返回数据的格式的，开发API的时候一般是返回JSON，所以这里指定为”application/json;charset=UTF-8” @RequestMapping.method我习惯于用POST来请求所有API，所以这里设置成了POST @RequestBody的使用和请求数据接收器@RequestBody会自动解析请求体的Body内容到指定的变量，这里是一个例子123456789101112131415161718192021public String login(@RequestBody RequestData data) &#123; if (data.code == null || data.code.isEmpty()) return error(101, \"缺少参数\"); TokenTransfer transfer = userService.loginByWxCode(data.code); if (transfer.getError() != 0) return error(transfer.getError(), transfer.getMsg()); JsonObject obj = new JsonObject(); obj.addProperty(\"error\", 0); obj.addProperty(\"token\", transfer.getToken()); return obj.toString();&#125;static class RequestData extends User &#123; String code; // 小程序传来的登陆code String token; // 小程序传来的用户token，用于识别用户 public void setCode(String code) &#123; this.code = code; &#125; public void setToken(String token) &#123; this.token = token; &#125;&#125;在这段代码中，User是一个pojo实体类，我基于它派生了一个请求数据类，并给它加上@RequestBody注解，前端传来的数据会解析到这个类中。 一般在一个控制器中，像新增数据、修改数据时一般都会用到对应的实体类中的字段，同时还会有其他字段，比如识别用户的token，小程序登陆是要用的code等，所以基于对应实体类派生一个专用的数据接收器还是挺妥的。这样做还有一个好处是，因为是基于pojo派生的，可以直接传递这个派生类到Service层，然后Service用基类pojo类接收（为什么不直接接收派生类？因为这样会破坏不同层之间的独立性，不便于维护，详见下一节）。 值得一提的是，在同一个控制器中，虽然有很多方法，但不必为每个方法单独派生数据接收器，实体类中有的字段可以直接用，没有的字段全部写入派生类中，SpringMVC不会因为一个你有的属性前端没传而产生不良后果。 这里我使用了一个名词：数据接收器，这不是专业说法，仅仅是为了叙述方便引入的 Controller层与Service层之间的数据传输注：这里只讨论通过方法的参数列表和返回值来传递数据 在传输数据方面，我习惯遵循一个原则：尽可能降低不同层之间的耦合程度。怎么说呢，举个例子，上一节创建的数据接收器是一个控制器的内部类，虽然只要声明为public也是可以在Service层引用的，但是一旦这么做了，对应的Controller和Service的耦合程度就会大大提高，设想如果另一个控制器想要调用同一个Service方法，还得找一个不相关的Controller下面的内部类，喵喵喵？？？ Controller -&gt; Service从Controller传数据到Service其实很容易，因为Controller调用的Service的方法，需要多少参数直接写在参数列表就好了。这里有一个Service方法设计的基本原则：方法参数不宜过长。很容易理解，如果Service提供一个有十几个甚至几十个参数的方法，你能记住参数的含义和顺序吗？网上大多推荐用一个包装类，但其实大多数情况下只需要一个对应实体类和其他的少数参数就足够了。上一节基于实体类派生了一个数据接收器来接收前端数据，在这里正好用上，把数据接收器直接传入Service，在Service用基类接收，然后其他参数以参数列表传入。如果遇到除了实体类还有一大堆参数的，就要考虑提取一个公用包装器了，这种情况我暂时还没遇到，不再赘述。 Service -&gt; Controller但是从Service返回数据就不那么方便了，如果Service要返回的东西很简单，简单到可以用一个基本类型或公用实体来表示的话，那没什么可说的，直接返回就好了。但如果要返回很复杂的东西，就不好办了，一方面Java中方法只能返回一个值，另一方面又不能让不同层之间耦合太过于严重。其实说难也不难解决，前面Controller传数据给Service时，不能传递自己类下面的内部类给Service，是因为一个Service可能会被多个Controller调用，但细细来考虑Controller和Service之间的关系，会发现总是由Service来提供服务，然后Controller来调用，我们也是一直这样做的，不可能出现Service调用Controller的情况。既然如此，在Controller使用Service的服务时，返回一个对应Service的专用返回数据包装器是合理的，“你要使用我提供的服务，就得遵守我的规则”。 引入Transfer1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 基本接口，大多数情况下Controller只需要知道Service执行的有没有错误，有的话错误代号和错误信息是什么public interface Transfer &#123; int getError(); String getMsg();&#125;// 基本实现public class BaseTransfer implements Transfer &#123; private int error = 0; private String msg; public int getError() &#123; return error; &#125; public BaseTransfer setError(int error) &#123; this.error = error; return this; &#125; public String getMsg() &#123; return msg; &#125; public BaseTransfer setMsg(String msg) &#123; this.msg = msg; return this; &#125;&#125;// 如果还需要更多的信息，就需要自定义一个类来实现基本接口了public class TokenTransfer implements Transfer &#123; private int error = 0; private String token; private String msg; public int getError() &#123; return error; &#125; public TokenTransfer setError(int error) &#123; this.error = error; return this; &#125; public String getToken() &#123; return token; &#125; public TokenTransfer setToken(String token) &#123; this.token = token; return this; &#125; public String getMsg() &#123; return msg; &#125; public TokenTransfer setMsg(String msg) &#123; this.msg = msg; return this; &#125;&#125; 至此，Controller与Service两层之间的数据传输问题算是解决了。","categories":[{"name":"Java","slug":"Java","permalink":"https://hexo.xinsane.com/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://hexo.xinsane.com/categories/Java/SSM/"},{"name":"SpringMVC","slug":"Java/SSM/SpringMVC","permalink":"https://hexo.xinsane.com/categories/Java/SSM/SpringMVC/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.xinsane.com/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://hexo.xinsane.com/tags/SSM/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"https://hexo.xinsane.com/tags/SpringMVC/"}]},{"title":"Spring+SpringMVC+Mybatis学习之路","slug":"Spring+SpringMVC+Mybatis学习之路","date":"2018-04-21T06:51:40.000Z","updated":"2018-04-21T07:35:58.764Z","comments":true,"path":"2018/04/21/Spring+SpringMVC+Mybatis学习之路/","link":"","permalink":"https://hexo.xinsane.com/2018/04/21/Spring+SpringMVC+Mybatis学习之路/","excerpt":"","text":"这篇文章仅做学习过程的记录，不涉及技术问题 引言前段时间确定了走JavaWeb方向，所以在了解过Servlet和JSP之后便义无反顾的投入到了SSM三大框架的学习之中。在学习的过程中碰到了很多问题，而且很多很杂很乱，于是想写点什么来记录一下。这是我的第一篇技术博客，算是一次艰难的尝试吧2333 入门三大框架我是从视频开始入手学的。其实以前我比较反对看视频学习，因为视频学习的周期比较长，而且很容易形成一种跟视频中类似的思维定式，视频里不规范、做的不好的地方很难察觉，自己在潜移默化中就跟着形成了同样的问题。这一次之所以选择看视频是因为实在是没有合适的学习资源，以前我一般通过看书来学习新东西比较多，但是这三大框架的更新速度实在过快，英文版图书没有查过，但是合适的中文书实在是没找到，基本都是很久远年代的版本，虽然网上说大体架构差不多，但我还是觉得这样会遇到太多问题。于是最终选择了前两年发布的一套视频教程来作为入门学习。 实践在看视频的同时，我一边跟着视频写一些小测试，一边策划着用新学的框架写点什么。在把视频看完之后，便迫不及待的开始用它们来做一个当前的网站后台任务。看视频的时候觉得好像是这么回事，但是真正自己写的时候就完全不是那么回事了，各种问题，各种冗余，各种不爽，哎呀好气啊，怎么会这样呢？？？ 心平气和真的很重要，当我终于静下心来的时候，已经浪费了很多时间了，我才意识到，学习得有一个过程，不能一蹴而就。我也想过一上来就拿新学的东西做复杂的项目是不是有点不妥，但是我习惯于在实践中学习，一些很枯燥的东西，实践一下就能心中有数，所以我并没有放弃，那就只能一点一点的排查错误，最终找到了我已开始忽略但是十分十分重要的东西，那就是官方文档。为什么一开始不从官方文档看起？一方面是因为我英文不好，看着很吃力，但更重要的是我对这几个框架一点都不熟悉，甚至都不知道它们是用来干嘛的，这种情况下，看官方文档只会一头雾水。当我从视频中了解了它们的基本知识和架构了之后，官方文档就显得十分重要了。一个框架往往是十分庞大的，选择其中的一小部分便可以完成任务，所以跟着别人的脚步只能学到他当时用到的东西，而且框架更新也可能很快，这个时候看官方文档能对框架的一些特性进行比较全面的了解，不用每个特性都去实践，但是看过之后心中会有数，很多时候茫然不是不知道该怎么做，而是不知道能做什么。 记录在实践中遇到了很多问题，很多问题当时解决之后不长的一段时间就忘了，想重新去看的时候又不知道在什么地方了，才促使我写点东西来记录一下。当然这篇文章只是一个引子，具体内容还得慢慢写。","categories":[{"name":"Java","slug":"Java","permalink":"https://hexo.xinsane.com/categories/Java/"},{"name":"SSM","slug":"Java/SSM","permalink":"https://hexo.xinsane.com/categories/Java/SSM/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://hexo.xinsane.com/tags/Java/"},{"name":"SSM","slug":"SSM","permalink":"https://hexo.xinsane.com/tags/SSM/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"https://hexo.xinsane.com/tags/JavaWeb/"}]}]}